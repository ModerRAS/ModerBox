# 合闸电阻退出时刻检测提示词

## 任务描述

给定三相电流波形数据（50Hz环境，10000Hz采样率），检测合闸电阻退出时刻。输出为三相的退出时刻（毫秒，精度0.1ms）。

## 输入数据格式

- 采样率：10000Hz
- 记录时长：建议100ms以上
- 数据内容：三相电流值（单位：A）
- 数据顺序：时间序列，每行一个采样点

## 算法步骤

### 第一步：信号预处理

**1.1 去直流分量**

计算电流波形的初始均值，从所有采样点减去该均值：

```
mean_I = mean(I[0:100])  // 前100个点的均值
I_dc = I - mean_I
```

**1.2 IIR陷波滤波器设计**

设计二阶IIR陷波器，滤除50Hz基波：

| 参数 | 推荐值 |
|-----|-------|
| 类型 | 二阶IIR陷波器 |
| 中心频率 | 50Hz |
| 带宽 | 3Hz |
| 衰减深度 | >40dB |
| 采样率 | 10000Hz |

陷波器差分方程系数计算方法（用双线性变换法）：

```python
# 陷波器设计参数
fs = 10000  # 采样率
f0 = 50     # 中心频率
bw = 3      # 带宽（Hz）

# 计算系数
omega0 = 2 * pi * f0 / fs
alpha = sin(omega0) / (2 * Q)  # 其中Q = f0/bw = 50/3 ≈ 16.7
cos_omega0 = cos(omega0)

# 陷波器系数
b0 = 1
b1 = -2 * cos_omega0
b2 = 1
a0 = 1 + alpha
a1 = -2 * cos_omega0
a2 = 1 - alpha

# 归一化
b0 = b0 / a0
b1 = b1 / a0
b2 = b2 / a0
a1 = a1 / a0
a2 = a2 / a0
```

**1.3 高通滤波器设计**

设计一阶IIR高通滤波器，去除低频漂移：

| 参数 | 推荐值 |
|-----|-------|
| 类型 | 一阶IIR高通 |
| 截止频率 | 10Hz |
| 采样率 | 10000Hz |

高通滤波器系数：

```python
fc = 10    # 截止频率
fs = 10000 # 采样率
omega = 2 * pi * fc / fs
alpha = sin(omega) / (1 + cos(omega))  # 一阶高通系数

b0 = (1 + cos(omega)) / 2
b1 = -(1 + cos(omega)) / 2
a0 = 1 + alpha
a1 = -(1 - alpha)
```

**1.4 滤波处理**

对电流信号依次应用陷波滤波器和高通滤波器：

```python
I_filtered = highpass(notch(I_dc, params), fc=10)
```

陷波滤波后，50Hz基波被消除，信号应接近零均值，主要保留突变和噪声。

### 第二步：斜率计算

**2.1 窗口大小选择**

| 参数 | 推荐值 |
|-----|-------|
| 窗口点数 | 15-20点 |
| 窗口时长 | 1.5-2.0ms |

窗口不宜太小（噪声敏感），也不宜太大（平滑掉细节）。

**2.2 多项式拟合方法**

使用二阶多项式拟合计算瞬时斜率：

对于每个采样点i，以i为中心取窗口内的数据点，用二阶多项式拟合：

```
I(t) = a*t² + b*t + c

斜率 = dI/dt = 2*a*t + b
```

**2.3 斜率序列计算**

```python
def calculate_slope(data, window_size=15):
    """计算斜率序列"""
    slopes = []
    half_win = window_size // 2
  
    for i in range(len(data)):
        # 取窗口数据
        start = max(0, i - half_win)
        end = min(len(data), i + half_win + 1)
        window = data[start:end]
      
        if len(window) < 5:
            slopes.append(0)
            continue
      
        # 时间序列
        t = np.arange(len(window))
      
        # 二阶多项式拟合
        coeffs = np.polyfit(t, window, 2)
      
        # 斜率 = 2*coeffs[0]*t + coeffs[1]
        # 取窗口中心点的斜率
        center_t = len(window) // 2
        slope = 2 * coeffs[0] * center_t + coeffs[1]
      
        slopes.append(slope)
  
    return np.array(slopes)
```

**2.4 平滑处理**

对斜率序列进行轻度平滑，减少噪声影响：

```python
def smooth_slope(slope, window=5):
    """滑动平均平滑"""
    return np.convolve(slope, np.ones(window)/window, mode='same')
```

### 第三步：斜率变化检测

**3.1 计算斜率一阶差分**

```python
slope_diff = np.diff(slope_filtered)
```

**3.2 动态阈值计算**

基于斜率差分序列的统计特性自动计算阈值：

```python
# 方法1：基于标准差
mean_diff = np.mean(slope_diff)
std_diff = np.std(slope_diff)
threshold = mean_diff + 3 * std_diff  # 3倍标准差

# 方法2：基于最大值
max_diff = np.max(np.abs(slope_diff))
threshold = 0.3 * max_diff  # 最大值的30%
```

推荐使用方法2（基于最大值），因为斜率变化信号的特征更明显。

**3.3 检测斜率突变点**

```python
# 找所有超过阈值的点
candidates = np.where(slope_diff > threshold)[0]

# 去抖动：连续3个点都超过阈值才认为是有效检测
valid_candidates = []
for i in range(len(candidates) - 2):
    if (candidates[i+1] == candidates[i] + 1 and 
        cands[i+2] == candidates[i] + 2):
        valid_candidates.append(candidates[i] + 1)  # 加1是因为差分索引
```

**3.4 多重条件过滤**

对检测到的候选点进行过滤：

```python
def filter_candidates(candidates, current, time_array):
    """过滤无效候选点"""
    filtered = []
  
    for idx in candidates:
        t = time_array[idx]
      
        # 条件1：时刻在合理范围内（合闸后10-80ms）
        if t < 10 or t > 80:
            continue
      
        # 条件2：计算距离最近50Hz过零点的距离
        # 50Hz过零点间隔为10ms
        distance_to_zero = t % 10
        if distance_to_zero < 1 or distance_to_zero > 9:  # 避开过零点±1ms
            continue
      
        filtered.append(idx)
  
    return filtered
```

**3.5 选择最佳候选点**

如果存在多个候选点，选择斜率变化最大的那个：

```python
if len(filtered) > 0:
    # 选择斜率变化最大的点
    best_idx = filtered[np.argmax(slope_diff[filtered])]
    detection_time = time_array[best_idx]
else:
    detection_time = None  # 未检测到
```

### 第四步：亚像素精定位

**4.1 在检测点附近取数据段**

```python
# 取检测点前后各5个点
window_start = max(0, best_idx - 5)
window_end = min(len(slope_diff), best_idx + 6)
local_slope = slope_diff[window_start:window_end]
local_time = time_array[window_start:window_end]
```

**4.2 抛物线拟合斜率变化曲线**

```python
# 用抛物线拟合局部斜率变化
t = np.arange(len(local_slope))
coeffs = np.polyfit(t, local_slope, 2)

# 求抛物线极值点位置
# 极值点坐标：t = -b/(2a)
peak_position = -coeffs[1] / (2 * coeffs[0])

# 转换为实际时间
refined_time = time_array[window_start] + peak_position * 0.1  # 0.1ms per sample
```

### 第五步：三相结果验证

**5.1 检查三相一致性**

```python
def validate_three_phase(tA, tB, tC):
    """验证三相检测结果一致性"""
    if None in [tA, tB, tC]:
        return False, "某相未检测到"
  
    times = [tA, tB, tC]
    max_deviation = max(times) - min(times)
  
    if max_deviation < 0.5:
        return True, f"检测成功，三相偏差{max_deviation:.2f}ms"
    else:
        return False, f"三相偏差过大: {max_deviation:.2f}ms"
```

**5.2 不一致时的处理**

如果三相偏差超过0.5ms：
- 重新检查检测过程
- 考虑使用曲线拟合法重新验证
- 输出警告信息

### 第六步：输出结果

**输出格式**：

```json
{
    "phase_A": {
        "detection_time_ms": 12.3,
        "confidence": 0.85,
        "raw_detection_point": 123,
        "refined_point": 123.4
    },
    "phase_B": {
        "detection_time_ms": 12.4,
        "confidence": 0.82,
        "raw_detection_point": 124,
        "refined_point": 124.2
    },
    "phase_C": {
        "detection_time_ms": 12.3,
        "confidence": 0.88,
        "raw_detection_point": 123,
        "refined_point": 123.5
    },
    "validation": {
        "three_phase_consistent": true,
        "max_deviation_ms": 0.1,
        "overall_confidence": 0.85
    }
}
```

## 完整代码框架

```python
import numpy as np
from scipy import signal

class CircuitBreakerOpenDetector:
    """合闸电阻退出时刻检测器"""
  
    def __init__(self, fs=10000):
        self.fs = fs
      
        # 设计陷波滤波器（50Hz）
        self.notch_b, self.notch_a = self._design_notch_filter(f0=50, bw=3)
      
        # 设计高通滤波器（10Hz）
        self.hp_b, self.hp_a = self._design_highpass_filter(fc=10)
  
    def _design_notch_filter(self, f0, bw):
        """设计IIR陷波滤波器"""
        Q = f0 / bw
        omega0 = 2 * np.pi * f0 / self.fs
        alpha = np.sin(omega0) / (2 * Q)
        cos_omega0 = np.cos(omega0)
      
        b0 = 1
        b1 = -2 * cos_omega0
        b2 = 1
        a0 = 1 + alpha
        a1 = -2 * cos_omega0
        a2 = 1 - alpha
      
        b = [b0/a0, b1/a0, b2/a0]
        a = [1, a1/a0, a2/a0]
      
        return b, a
  
    def _design_highpass_filter(self, fc):
        """设计一阶高通滤波器"""
        omega = 2 * np.pi * fc / self.fs
        alpha = np.sin(omega) / (1 + np.cos(omega))
      
        b0 = (1 + np.cos(omega)) / 2
        b1 = -(1 + np.cos(omega)) / 2
        a0 = 1 + alpha
        a1 = -(1 - alpha)
      
        b = [b0/a0, b1/a0]
        a = [1, a1/a0]
      
        return b, a
  
    def preprocess(self, current):
        """信号预处理"""
        # 去直流
        mean_current = np.mean(current[:100])
        I_dc = current - mean_current
      
        # 陷波滤波
        I_notch = signal.filtfilt(self.notch_b, self.notch_a, I_dc)
      
        # 高通滤波
        I_filtered = signal.filtfilt(self.hp_b, self.hp_a, I_notch)
      
        return I_filtered
  
    def calculate_slope(self, data, window_size=15):
        """计算斜率"""
        slopes = []
        half_win = window_size // 2
      
        for i in range(len(data)):
            start = max(0, i - half_win)
            end = min(len(data), i + half_win + 1)
            window = data[start:end]
          
            if len(window) < 5:
                slopes.append(0)
                continue
          
            t = np.arange(len(window))
            coeffs = np.polyfit(t, window, 2)
            center_t = len(window) // 2
            slope = 2 * coeffs[0] * center_t + coeffs[1]
            slopes.append(slope)
      
        return np.array(slopes)
  
    def detect_slope_change(self, slope, time_array):
        """检测斜率变化"""
        # 斜率差分
        slope_diff = np.diff(slope)
      
        # 动态阈值
        max_diff = np.max(np.abs(slope_diff))
        threshold = 0.3 * max_diff
      
        # 检测超过阈值的点
        candidates = np.where(slope_diff > threshold)[0]
      
        # 去抖动：连续3个点
        valid = []
        for i in range(len(candidates) - 2):
            if (candidates[i+1] == candidates[i] + 1 and 
                candidates[i+2] == candidates[i] + 2):
                valid.append(candidates[i] + 1)
      
        # 多重条件过滤
        filtered = []
        for idx in valid:
            t = time_array[idx]
            # 时刻范围检查
            if t < 10 or t > 80:
                continue
            # 过零点距离检查
            dist = t % 10
            if dist < 1 or dist > 9:
                continue
            filtered.append(idx)
      
        # 选择最佳候选点
        if len(filtered) > 0:
            best_idx = filtered[np.argmax(slope_diff[filtered])]
            return best_idx
        return None
  
    def refine_position(self, slope, idx, time_array):
        """亚像素精定位"""
        window_start = max(0, idx - 5)
        window_end = min(len(slope), idx + 6)
      
        if window_end - window_start < 7:
            return time_array[idx]
      
        local_slope = slope[window_start:window_end]
        t = np.arange(len(local_slope))
        coeffs = np.polyfit(t, local_slope, 2)
      
        if abs(coeffs[0]) < 1e-10:
            return time_array[idx]
      
        peak_position = -coeffs[1] / (2 * coeffs[0])
        refined_time = time_array[window_start] + peak_position * 0.1
      
        return refined_time
  
    def detect(self, current_A, current_B, current_C):
        """主检测函数"""
        # 时间序列
        n = len(current_A)
        time_array = np.arange(n) * 0.1  # 0.1ms per sample
      
        # 预处理
        I_A = self.preprocess(current_A)
        I_B = self.preprocess(current_B)
        I_C = self.preprocess(current_C)
      
        # 计算斜率
        slope_A = self.calculate_slope(I_A)
        slope_B = self.calculate_slope(I_B)
        slope_C = self.calculate_slope(I_C)
      
        # 检测
        idx_A = self.detect_slope_change(slope_A, time_array)
        idx_B = self.detect_slope_change(slope_B, time_array)
        idx_C = self.detect_slope_change(slope_C, time_array)
      
        # 亚像素精定位
        t_A = self.refine_position(slope_A, idx_A, time_array) if idx_A is not None else None
        t_B = self.refine_position(slope_B, idx_B, time_array) if idx_B is not None else None
        t_C = self.refine_position(slope_C, idx_C, time_array) if idx_C is not None else None
      
        # 三相验证
        times = [t_A, t_B, t_C]
        if None not in times:
            max_dev = max(times) - min(times)
        else:
            max_dev = None
      
        return {
            'phase_A': {'time_ms': t_A, 'raw_idx': idx_A},
            'phase_B': {'time_ms': t_B, 'raw_idx': idx_B},
            'phase_C': {'time_ms': t_C, 'raw_idx': idx_C},
            'validation': {'max_deviation_ms': max_dev}
        }


# 使用示例
if __name__ == "__main__":
    detector = CircuitBreakerOpenDetector(fs=10000)
  
    # 加载数据
    # current_A, current_B, current_C = load_data("waveform.csv")
  
    # 检测
    result = detector.detect(current_A, current_B, current_C)
    print(result)
```

## 关键参数总结

| 步骤 | 参数 | 推荐值 | 说明 |
|-----|-----|-------|------|
| 陷波滤波 | 中心频率 | 50Hz | 必须准确 |
| 陷波滤波 | 带宽 | 3Hz | 窄带宽去基波 |
| 高通滤波 | 截止频率 | 10Hz | 去低频漂移 |
| 斜率计算 | 窗口大小 | 15点 | 1.5ms窗口 |
| 斜率计算 | 拟合阶数 | 2阶 | 抛物线拟合 |
| 变化检测 | 阈值系数 | 0.3 | 基于最大值 |
| 变化检测 | 去抖动 | 连续3点 | 防止误检 |
| 条件过滤 | 时刻范围 | 10-80ms | 合闸后合理时间 |
| 条件过滤 | 过零点距离 | >1ms | 避开过零点 |
| 亚像素 | 方法 | 抛物线插值 | 精度0.25采样间隔 |

## 注意事项

1. **陷波滤波器频率必须准确**：如果电网频率有偏差（50±0.5Hz），需要相应调整陷波器中心频率

2. **采样率足够**：10000Hz采样率可以准确检测50Hz波形，但要注意抗混叠

3. **数据质量**：确保故障录波器记录的波形没有削波或饱和

4. **先试试看**：如果检测结果不稳定，可以尝试调整阈值系数（0.2-0.5）和窗口大小（12-20点）

5. **如果误判**：考虑加入曲线拟合法作为二次验证